..
   Copyright 2009-2015 Ram Rachum. This work is licensed under a Creative
   Commons Attribution-ShareAlike 3.0 Unported License, with attribution to
   "Ram Rachum at ram.rachum.com" including link. The license may be obtained
   at http://creativecommons.org/licenses/by-sa/3.0/

.. bags:

Bags
====

Combi provides 4 bag classes: 

* :class:`Bag` - The simplest bag class
* :class:`FrozenBag` - An immutable (and thus hashable) bag class
* :class:`OrderedBag` - A bag class where items are ordered by insertion order
* :class:`FrozenOrderedBag` - An immutable, ordered bag class

.. class:: Bag(iterable={})

   The :class:`Bag` class is an implementation of the mathematical concept of a
   `multiset`_; meaning something like a set, except that every item could
   appear multiple times, and crucially, we only save the *count* of the item
   in memory instead of saving multiple copies of the same item, which would be
   a waste of memory.
   
   You may know the :class:`collections.Counter` class from Python's standard
   library; the bag classes provided by Combi are very similar, except that
   they are more strictly defined as multisets, meaning that counts must be
   positive integers. (Zeros are allowed in input but they are weeded out.) By
   contrast, :class:`collections.Counter` allows any value as an item's count.
   
   This restriction makes the bag classes more powerful than
   :class:`collections.Counter` because it allows more methods to be defined.
   More arithmetical operations are defined, comparison between bags is
   supported, and more.
   
   When you create a bag, it will be populated with the ``iterable`` argument.
   If ``iterable`` is a plain sequence, its items will be added one-by-one:
       
      >>> Bag('abracadabra')
      Bag({'c': 1, 'b': 2, 'd': 1, 'a': 5, 'r': 2})
       
   If ``iterable`` is a mapping, its values will be taken as item counts:
   
      >>> Bag({'meow': 2, 'woof': 5,})
      Bag({'meow': 2, 'woof': 5})

   
   :class:`Bag` can be accessed similarly to a :class:`dict` or :class:`Counter
   <collections.Counter>`:
   
      >>> my_bag = Bag('abracadabra')
      >>> my_bag['b']
      2
      >>> 'x' in my_bag
      False
      >>> my_bag['x'] = 7
      >>> my_bag
      Bag({'r': 2, 'x': 7, 'b': 2, 'a': 5, 'd': 1, 'c': 1})
      >>> 'x' in my_bag
      True
      >>> my_bag['y'] # If it's not in the bag, the count is zero:
      0
      >>> for key, count in my_bag.items():
      ...     print((key, count))
      ... 
      ('r', 2)
      ('x', 7)
      ('b', 2)
      ('a', 5)
      ('d', 1)
      ('c', 1)

      

   .. attribute:: blocktododoc fill in 

       A user updateable list of mappings.  The list is ordered from
       first-searched to last-searched.  It is the only stored state and can
       be modified to change which mappings are searched.  The list should
       always contain at least one mapping.

   .. method:: new_child(m=None) blocktododoc fill in 

       Returns a new :class:`ChainMap` containing a new map followed by
       all of the maps in the current instance.  If ``m`` is specified,
       it becomes the new map at the front of the list of mappings; if not
       specified, an empty dict is used, so that a call to ``d.new_child()``
       is equivalent to: ``ChainMap({}, *d.maps)``.  This method is used for
       creating subcontexts that can be updated without altering values in any
       of the parent mappings.

       .. versionchanged:: 3.4
          The optional ``m`` parameter was added.



Comparisons between bags
------------------------

One of the advantages of :class:`Bag` over :class:`collections.Counter` is that
:class:`Bag` provides comparison methods between bags, that act similarly to
comparisons between Python's built-in sets. This makes it easy to see whether
one bag is contained by another. Example:

   >>> sandwich = Bag({'bread': 2, 'cheese': 1, 'tomato': 2, 'burger': 1,})
   >>> vegan_sandwich = Bag({'bread': 2, 'tomato': 2,})
   >>> vegan_sandwich < sandwich
   True
   >>> salad = Bag({'tomato': 2, 'bell pepper': 1,})
   >>> salad < sandwich # False because there's no bell pepper in our sandwich
   False 

A bag is smaller-or-equal to another bag if it's "contained" in it, meaning
that every key in the contained bag also exists in the containing bag, and with
a count that's bigger or equal to its count in the contained bag.

A bag is strictly smaller than another bag if the above holds, and there's at
least one key for which the count in the containing bag is strictly bigger than
its count in the contained bag.

Please note that unlike most comparisons in Python, this is a `partial order`_
rather than a total one, meaning that for some pairs of bags, neither ``x >=
y`` nor ``y >= x`` holds true. This is similar to set comparison in Python.

Arithmetic operations on bags
-----------------------------

Another advantage of :class:`Bag` over :class:`collections.Counter` is that
:class:`Bag` provides a *wealth* of arithmetic operations (addition,
subtraction, etc.) between bags, and between bags and integers.

The basic arithmetic operations do what you expect them to, operating on the
counts of items:

   >>> sandwich = Bag({'bread': 2, 'cheese': 1, 'tomato': 2, 'burger': 1,})
   >>> salad = Bag({'tomato': 2, 'bell pepper': 1,})
   >>> single_tomato = Bag({'tomato': 1,})
   >>> sandwich + single_tomato # Addition
   Bag({'cheese': 1, 'bread': 2, 'tomato': 3, 'burger': 1})
   >>> sandwich - single_tomato # Subtraction 
   Bag({'cheese': 1, 'bread': 2, 'tomato': 1, 'burger': 1})
   >>> sandwich * 3 # Multiplication
   Bag({'cheese': 3, 'bread': 6, 'tomato': 6, 'burger': 3})
   
As for division: You can divide one bag by another to get an integer saying how
many times the second bag would go into the first. You can also divide a bag by
an integer, which will divide all the counts by that integer, rounding down.
All bag division is done with the floor-division operator ``//``, because it's
always rounded-down. Examples:

   >>> sandwich // single_tomato # Floor-division by another bag
   2
   >>> sandwich // 2 # Floor-division by integer
   Bag({'bread': 1, 'tomato': 1})
   
The more advanced operations are also supported:

   >>> sandwich % salad # Modulo by bag
   Bag({'bread': 2, 'cheese': 1, 'burger': 1, 'tomato': 2})
   >>> divmod(sandwich, salad) # Divmod by bag
   (0, Bag({'tomato': 2, 'cheese': 1, 'bread': 2, 'burger': 1}))
   >>> salad % 2 # Modulo by integer
   Bag({'bell pepper': 1})
   >>> divmod(salad, 2) # Divmod by integer
   (Bag({'tomato': 1}), Bag({'bell pepper': 1}))
   >>> salad ** 3 # Exponentiation
   Bag({'tomato': 8, 'bell pepper': 1})
   >>> pow(salad, 3, 5) # Exponentiation with modulo
   Bag({'tomato': 3, 'bell pepper': 1})

And... Did someone say logical operations? Like in Python sets, these do
`union`_ and `intersection`_:

   >>> sandwich | salad # Logical or, a.k.a. set union
   Bag({'bread': 2, 'cheese': 1, 'burger': 1, 'tomato': 2, 'bell pepper': 1})
   >>> sandwich & salad # Logical and, a.k.a. set intersection
   Bag({'tomato': 2})
   
As a final note about arithmetic operations, augmented assignment is supported
for all operations, so you can elegantly mutate bags in-place like this:

   >>> sandwich += Bag({'bacon': 2, 'egg': 1,})
   >>> sandwich
   Bag({'cheese': 1, 'bacon': 2, 'bread': 2, 'egg': 1, 'burger': 1, 'tomato': 2})
   >>> sandwich **= 2
   >>> sandwich
   Bag({'cheese': 1, 'bacon': 4, 'bread': 4, 'egg': 1, 'burger': 1, 'tomato': 4})
   

.. _multiset: https://en.wikipedia.org/wiki/Multiset
.. _partial order: https://en.wikipedia.org/wiki/Partially_ordered_set
.. _union: http://en.wikipedia.org/wiki/Union_(set_theory)
.. _intersection: http://en.wikipedia.org/wiki/Intersection_(set_theory)